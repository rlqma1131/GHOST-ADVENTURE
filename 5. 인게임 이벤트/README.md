# GHOST-ADVENTURE


연출 시스템 및 렌더링 



본 프로젝트는 게임의 스토리텔링과 시각적 몰입감을 극대화하기 위해 진행되었습니다. 
타임라인을 중심으로 한 모듈식 컷씬 시스템을 구축하고 Additive씬을 로드시켜 기존 씬 위에 연출을 보여주고 닫는 방법을 채택했습니다.
이러한 이유는 씬을 전환하는 동안 플레이어의 몰입감을 유지하고, 연출이 끝난 후에도 원활하게 게임플레이로 돌아갈 수 있도록 하기 위함입니다.
URP(Universal Render Pipeline) 도입과 포스트 프로세싱을 비주얼 퀄리티와 성능을 모두 개선하는 것을 목표로 했습니다.

핵심 설계 및 설계 철학

컷신의 '모듈화'와 TimeLineControl를 이용한 중앙 관리를 핵심 설계 철학으로 삼았습니다. 
각 컷씬을 독립적인 씬(Scene)으로 분리하여 모듈화했으며
게임의 전반적인 상태(UI, 사운드, 플레이어 제어)는 컷신이 재생되는 동안 TImeScale을 0으로 멈추고 컷신 종료시 원상태로 복구시켜 재생되는 컷신동안 플레이어가 공격당하거나 의도치 않은 조작이 이루어지는걸 방지했습니다.
이를 통해 시스템 간의 의존성을 낮추고, 안정적이며 확장 가능한 구조를 구현했습니다.


게임 개발자를 꿈꾸는 사람으로서 작성하는 코드의	가독성과 유지보수성을 항상 염두에 두는것도 중효 하지만
이번 프로젝트에서 연출을 맡음으로서 보여지는 비주얼 퀄리티와 몰입감을 높이는 것 또한 중점을 두었습니다.
시장에 내 놓은 게임들이 대부분 비주얼 퀄리티와 몰입감을 중시하는 만큼 아무리 코드가 잘 작성되어도 플레이어가 게임에 몰입하지 못한다면 좋은 게임이라고 할 수 없기 때문입니다.
이러한 목표를 달성하기 위해 제작된 연출들을 다른 사람에게 보여줬을때 꼭 '와 이런 연출을 어떻게 만든거지?'라는 반응을 얻고 싶었습니다.
때문에 Unity의 Timeline과 Cinemachine을 활용하여 컷씬을 제작했습니다.
본 프로젝트는 제한된 인력과 개발 기간 안에서 높은 연출 퀄리티를 확보해야 했기에,
컷씬 시스템의 모듈화와 재사용성을 중점으로 설계했습니다. 
연출 파트 제작을 혼자 담당하여 기획, 제작, 사운드 믹싱, 코드 구현까지 직접 수행했습니다.”

주요 특징

본 게임 환경 격리: 컷씬 재생 시 메인 게임 씬의 Time.timeScale을 0으로 설정하고, 컷씬 씬은 Additive 방식으로 로드하여 게임 로직과 연출 환경을 완벽하게 분리했습니다.


타임라인 기반 제어: 유니티 타임라인을 연출의 중심으로 사용하여 애니메이션, 카메라, 사운드 등 모든 요소를 시각적으로 제어하고, Signal Emitter를 통해 코드와 상호작용합니다.

매니저 기반 상태 복원: 컷씬 종료 시 SoundManager, UIManager, GameManager 등 중앙 관리 시스템이 게임의 모든 상태(BGM, UI, 플레이어 이동 가능 여부 등)를 안전하게 기존씬의 형태로 원상 복구합니다.

직관적인 스킵 기능: Time.timeScale에 영향을 받지 않는 UnscaledGameTime을 사용하여,  실수로 스킵되는 것을 방지하기 위해 3초간 키를 누르고 있어야만 컷씬이 스킵되는 직관적이고 안정적인 스킵 UI/UX를 구현했습니다.



폴더 구조
프로젝트의 가독성과 유지보수 효율을 높이기 위해 다음과 같이 역할을 기준으로 폴더 구조를 설계했습니다.

01.Scripts/TimeLine:  컷씬 연출의 핵심 제어 로직을 관리하는 폴더입니다.
예를 들어, 컷씬의 시작과 종료, 타임라인의 재생 및 일시정지, 스킵 기능 등을 담당하는 스크립트가 포함되어 있습니다.

01.Scripts/Image: 컷씬 연출 중 사용되는 커스텀 이미지(스프라이트, 텍스처 등)를 재구성하기 위한 스크립트 폴더입니다.. 
PixelExploder.cs 는 픽셀 아트 스타일의 스프라이트를 분해하여 연출에 활용하는 스크립트입니다.
이번 프로젝트에서는 수집 아이템의 픽셀 아트 스프라이트를 분해하여 흡수되는 연출과 게임 오버시 플레이어가 깨지는 장면에서 효과적으로 사용했습니다.

01.Scripts/Camera: 플레이 중 카메라 조작, 특정 상황에서 카메라간 전환이 이루어질때 사용되는 스크립트 관리하는 폴더입니다.

04.Images/Scene : 컷씬 연출에 사용되는 이미지 리소스를 관리하는 폴더입니다.

06.Audio/TimeLine : 컷씬 연출 중 사용되는 오디오 리소스를 관리하는 폴더입니다.

10.TimeLine : 컷씬 연출을 위한 타임라인 리소스를 관리하는 폴더입니다. 
PlayableAsset 등 타임라인 관련 에셋이 있습니다. 

주요 기능 구현
1. 타임라인 기반의 컷씬 시스템 구축
[문제] 스크립트 기반 컷씬은 동기화가 어렵고 비프로그래머의 수정이 힘들어 협업 효율이 저하되었습니다.
[개선] 타임라인을 중심으로 애니메이션, 사운드 등을 시각적으로 배치하여 직관적인 작업 환경을 구축했습니다.
[결과] 제작 시간이 단축되고 연출 완성도가 높아졌으며 시각적인 디버깅 또한 가능했고, 항상 동일한 연출을 보장할 수 있게 되었습니다.


2. Additive 씬 로드를 통한 안정적인 컷씬 환경 조성
[문제] 메인 씬에서 컷씬을 재생할 경우, 기존 게임 로직(AI, 플레이어 입력)이 연출에 개입하는 오류가 발생했습니다.
[개선] 컷씬 전용 씬을 Additive 방식으로 로드하고 메인 씬의 시간을 정지시켜 완벽히 분리된 환경을 만들었습니다.
       이러한 이유는 Additive는 메모리 사용량이 약간 늘지만, 게임 상태를 보존하고 빠르게 복귀 가능하기 때문입니다.
[결과] 외부 요소 개입을 원천 차단하여 안정적인 연출이 가능해졌고, 프로젝트 구조가 모듈화되어 유지보수가 용이해졌습니다.

3. Signal Emitter를 통한 코드와 타임라인의 유기적 연동
[문제] 타임라인과 코드 간의 상호작용이 불편하여 연출 중 이벤트 처리가 어려웠습니다.
[개선] Signal Emitter를 사용하여 타임라인에서 특정 시점에 코드 이벤트를 발생시켜 유기적으로 연동했습니다.
[결과] 연출 중 필요한 이벤트 처리가 용이해졌고, 코드와 타임라인 간의 협업이 원활해졌습니다.

4. URP 도입을 통한 렌더링 성능 최적화
[문제] Built-in 파이프라인은 다양한 플랫폼에서의 성능 확보에 한계가 있고, 드로우 콜 부하가 높았습니다.
[개선] **URP(Universal Render Pipeline)**로 전환하고 SRP Batcher를 활성화하여 CPU 부하를 크게 줄였습니다.
[결과] 전반적인 프레임 속도(FPS)가 향상되었고, 셰이더 그래프 도입으로 그래픽스 작업의 생산성이 증대되었습니다.

5. 포스트 프로세싱을 활용한 게임 분위기 연출
[문제] URP 전환 후에도 기본 화면은 밋밋하여 게임의 고유한 분위기를 전달하기에 부족했습니다.
[개선] URP에 최적화된 볼륨 기반 포스트 프로세싱을 적용하여 Color Grading, Bloom 등으로 시각 효과를 더했습니다.
[결과] 게임의 독창적인 분위기를 구축하여 플레이어의 몰입감을 극대화하고, 비주얼 퀄리티를 크게 향상시켰습니다.

6. 자체 제작 리소스를 통한 연출력 강화
[문제] 연출에 필요한 특정 사운드나 이미지가 에셋 스토어에 없거나 게임의 아트 스타일과 맞지 않았습니다.
[개선] 필요한 효과음은 직접 녹음하고 FL Studio의 플러그인을 통해 믹싱 작업을 거쳤습니다, 특정 이미지는 직접 촬영 후 편집하여 리소스로 사용했습니다.
[결과] 기성 에셋으로는 표현 못 할 게임만의 독창적인 분위기를 완성하고, 비용과 시간을 절약하며 연출의 디테일을 높였습니다.

코드 예시 및 분석

TimelineControl.cs
Additive 씬으로 로드된 타임라인을 제어하고, 컷씬 종료 시 게임 상태를 안전하게 복원하는 핵심 스크립트입니다.

UnscaledGameTime 설정: Awake()에서 타임라인의 업데이트 모드를 UnscaledGameTime으로 설정하는 것은 이 시스템의 핵심입니다.
이를 통해 메인 씬의 Time.timeScale을 0으로 만들어 게임을 '일시정지'시킨 상태에서도, 타임라인은 정상적으로 재생될 수 있습니다.

hold-to-Skip 기능: Update()에서 Time.unscaledDeltaTime을 사용하여 Time.timeScale의 영향을 받지 않는 타이머를 구현했습니다. 
이는 Time.timeScale이 0인 컷씬 환경에서도 스킵 기능이 안정적으로 작동하게 만듭니다.

CloseScene() 중앙 관리: 이 함수는 컷씬을 종료하는 단순한 역할을 넘어, UIManager, EnemyAI, PossessionSystem, SoundManager 등 각 기능의 매니저(싱글톤)에 접근하여 게임 상태를 원래대로 되돌리는 중앙 관제탑 역할을 수행합니다. 
이는 각 시스템이 잘 분리되어 있으면서도 필요할 때 유기적으로 상호작용하는 좋은 설계 구조를 보여줍니다.

CameraChange.cs - 영역 기반 카메라 전환
이 스크립트는 특정 구역(Trigger)에 진입했을 때 카메라를 전환하는 핵심 역할을 합니다.

동작 방식: 플레이어가 이 스크립트가 적용된 트리거 영역에 들어가면, 연결된 카메라(Vcam)의 우선순위(Priority)를 높여 해당 카메라를 활성화합니다.

역할: 각 방이나 특정 구역마다 배치하여, 플레이어의 위치에 따라 가장 적절한 구도의 카메라를 자동으로 보여주는 기능을 담당합니다.

CameraTargetSetter.cs - 안전한 개별 타겟 설정
이 스크립트는 카메라가 특정 타겟(예: 플레이어, NPC 등)을 추적하도록 설정하는 역할을 합니다.

동작 방식: GameManager를 통해 플레이어 캐릭터가 생성될 때까지 안전하게 기다린 후(WaitUntil), 자신이 부착된 가상 카메라의 Follow 타겟을 플레이어로 지정합니다.

역할: 씬 로딩 순서 등으로 인해 플레이어가 아직 없을 때 발생하는 오류를 방지합니다. 
각 카메라에 개별적으로 부착하여, 특정 카메라만 플레이어를 추적하게 만들고 싶을 때 사용하는 더 정교하고 안정적인 방법입니다.


PlayerCamera.cs - 현재 카메라 상태 추적
이 스크립트는 플레이어 오브젝트에 부착되어, 현재 어떤 방의 카메라가 활성화되어야 하는지에 대한 정보를 저장하는 역할을 합니다.

동작 방식: "Room" 태그를 가진 트리거에 진입하면, 해당 트리거의 CameraChange 스크립트로부터 활성화될 가상 카메라(Vcam) 정보를 가져와 currentCam 변수에 저장합니다.

역할: 실제 카메라를 전환하기보다는, 플레이어가 현재 어떤 카메라의 영향권 안에 있는지를 추적하는 상태 관리 기능을 수행합니다.

CutsceneManager.cs - 컷씬 관리 및 상태 복원


이 스크립트는 게임의 특정 시점에 컷씬을 재생하고, 컷씬이 끝난 후나 씬이 비정상적으로 언로드될 때 게임 상태를 안정적으로 관리하는 역할을 합니다.

컷씬 재생 제어: PlayCutscene 코루틴을 통해 PlayableDirector(타임라인)를 재생하고, 재생이 완료될 때까지 기다리는 로직을 수행합니다.

페이드 효과 관리: fadePanel 게임 오브젝트를 제어하여, 컷씬이 끝난 후 화면을 가리는 페이드 패널을 비활성화합니다.

상태 안전장치: 씬이 언로드될 때 Time.timeScale을 1로 복원하고 페이드 패널을 끄는 안전장치를 마련하여, 게임이 멈추거나 UI가 화면에 남는 문제를 방지합니다.

동작 방식

이 매니저는 싱글톤으로 구현되었습니다. 이를 통해 씬 어디에서든 CutsceneManager.Instance로 쉽게 접근하여 PlayCutscene 같은 기능을 호출할 수 있습니다.

PlayCutscene 코루틴은 타임라인이 끝났는지 매 프레임마다 확인하는 대신, director.stopped 이벤트를 사용합니다.

타임라인 재생이 끝나면 OnPlayableDirectorStopped 함수가 호출되어 isDone 플래그를 true로 바꿉니다.

yield return new WaitUntil(() => isDone); 코드는 isDone이 true가 될 때까지 기다리므로, 불필요한 부하 없이 효율적으로 컷씬 종료 시점을 감지합니다.

OnEnable에서 SceneManager.sceneUnloaded 이벤트에 OnSceneUnloaded 메서드를 등록합니다.

이로 인해 컷씬 재생 중 다른 이유로 씬이 언로드되는 예외적인 상황이 발생하더라도, OnSceneUnloaded 함수가 호출되어 Time.timeScale을 1로 복원하고 fadePanel을 비활성화합니다. 
이는 게임이 멈추는 치명적인 버그를 예방하는 매우 중요한 안전장치입니다.

TypewriterDialogue.cs - 다기능 대화 출력 시스템

씬 중에 타자기처럼 한 글자씩 나타나는 텍스트 효과를 구현합니다. 
다양한 연출을 위해 여러 모드(수동/자동, 일반/흔들림)를 지원하며, Timeline 시스템과 유기적으로 연동되도록 설계되었습니다.

주요 기능 및 역할


타이핑 효과: 텍스트를 한 글자씩 출력하여 사용자의 주목도를 높이고, 타이핑하는 듯한 느낌을 줍니다.

대화 묶음 관리: 인스펙터에서 여러 개의 대화 묶음(DialogueSet)을 만들어 관리할 수 있어, 비프로그래머도 손쉽게 대사를 추가하거나 수정할 수 있습니다.

다양한 출력 모드:

수동/자동 모드: 마우스 클릭으로 대사를 넘기거나, 정해진 시간 후 자동으로 다음 대사가 나오게 할 수 있습니다.

흔들림 효과: DOTween 라이브러리를 사용하여 특정 대사를 흔들며 출력함으로써, 긴급하거나 격앙된 감정을 효과적으로 표현합니다.

타임라인 연동: 컷씬의 타임라인을 일시정지시키고, 대화가 모두 끝나면 타임라인을 다시 재생시키는 제어권을 가집니다.

동작 방식

데이터 중심 설계 (DialogueSet)

DialogueSet이라는 내부 클래스를 만들어, 여러 줄의 대사(string[])를 하나의 이름(setName)으로 묶어 관리합니다. 
public DialogueSet[] allDialogueSets 배열을 통해 이 묶음들을 인스펙터에서 편리하게 관리할 수 있어, 코드 수정 없이 대화 콘텐츠를 제작할 수 있습니다.

코루틴 기반의 비동기 텍스트 출력

TypeLine 같은 코루틴을 사용하여 텍스트를 출력합니다. 
foreach (char letter in ...) 루프를 돌며 한 글자씩 텍스트를 추가하고,
yield return new WaitForSecondsRealtime(typingSpeed);을 통해 글자 사이의 지연 시간을 만듭니다.

WaitForSecondsRealtime을 사용하여 Time.timeScale이 0인 상태(컷씬을 위해 게임을 멈춘 상태)에서도 대화가 정상적으로 출력되도록 했습니다.

사용자 입력 처리 (Update)

Update 메서드에서 마우스 클릭을 감지하여 세 가지 상황을 처리합니다.

타이핑 중 클릭: skipTyping 플래그를 true로 바꿔, 진행 중인 타이핑을 즉시 완료하고 문장 전체를 보여줍니다.

타이핑 완료 후 클릭: 다음 대사가 남아있으면 NextLine()을 호출하여 다음 문장을 출력합니다.

모든 대화 종료 후 클릭: 대화창을 닫고 timelineControl.ResumeTimeline()을 호출하여 멈춰있던 컷씬을 재개합니다.